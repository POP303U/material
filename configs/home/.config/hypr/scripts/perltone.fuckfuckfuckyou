#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use Graphics::ColorUtils;
use Color::Scheme;
use File::Basename;
use File::Path qw(make_path);
use List::Util qw(min);
use List::Util qw(max);
use Image::Magick;

# Check if ImageMagick is installed
if (!`which magick`) {
    print "Error: ImageMagick is not installed. Please install it to use this script.\n";
    exit 1
}

# Define options
my $pastel;
my $balanced;
my $vibrant;
my $stale;
my $light;
my $dark;
my $fast;
my $slow;
my $ultraspeed;
my $nuclear;

# Parse command line options
GetOptions(
    "p|pastel"  => \$pastel,
    "b|balanced" => \$balanced,
    "v|vibrant" => \$vibrant,
    "s|stale" => \$stale,
    "l|light" => \$light,
    "d|dark" => \$dark,
    "f|fast" => \$fast,
    "s|slow" => \$slow,
    "u|ultraspeed" => \$ultraspeed,
    "n|nuclear" => \$nuclear,
) or die("Error in command line arguments\n");

# Check if an image file is provided and provide help
if (@ARGV <= 1) {
    show_help();
}

# Check if the provided file exists
my $image_file = $ARGV[0];
if (!-f $image_file) {
    print "Error: File '$image_file' not found.\n";
    exit 1;
}

my $output_file = $ARGV[1];
if (!-f $output_file) {
    print "Error: File '$output_file' not found.\n";
    exit 1;
}

# // Variables here // #
my $background_cv_threshold = 40; # Threshold for maximum color brightness and luminance on backgrounds
my $saturation_threshold = 0.4;
my $brightness_threshold = 100;
my $max_background_luminance = 1; # Maximum luminance allowed for the colors
my $lighten_colors_fact = 0.12;
my $image_resize_fact= 25;

my $image_colors = 4;
my $image_fuzz = 70;

### Evaluate cli arguments
my $hsl_modifiers = "";
$hsl_modifiers = "-modulate 100,100,100" if $pastel and $dark;
$hsl_modifiers = "-modulate 100,100,100" if $balanced and $dark;
$hsl_modifiers = "-modulate 100,100,100" if $vibrant and $dark;
$hsl_modifiers = "-modulate 100,100,100" if $stale and $dark;
$hsl_modifiers = "-modulate 100,100,100" if $pastel and $light;
$hsl_modifiers = "-modulate 100,100,100" if $balanced and $light;
$hsl_modifiers = "-modulate 100,100,100" if $vibrant and $light;
$hsl_modifiers = "-modulate 100,100,100" if $stale and $light;

my $_raw_colors = `convert $image_file -resize 25% -depth 8 -kmeans 8 -unique-colors txt:- | grep -Po "(?<=#)[0-9a-fA-F]{6}"`;
my @raw_colors = split('\n', $_raw_colors);

my $scheme = Color::Scheme->new
    ->from_hex($raw_colors[0])
    ->scheme('analogic')
    ->distance(0.3)
    ->add_complement(1)
    ->variation('pastel')
    ->web_safe(1);

my $background = ($scheme->colors)[1];
my $main_bg = ($scheme->colors)[5];

my $darkest = adjust_color_brightness($background, 0.4, 'darken');
my $base = adjust_color_brightness($background, 0.4, 'darken');
my $base_tr = hex_to_rgba(adjust_color_brightness($darkest, 0.04, 'brighten'), 0.7);
my $surface = adjust_color_brightness($background, 0.4, 'brighten');
my $overlay = adjust_color_brightness($background, 0.4, 'brighten');
my $muted = adjust_color_brightness($background, 0.5, 'brighten');
my $subtle = adjust_color_brightness($background, 0.6, 'brighten');
my $foreground_color = adjust_color_brightness($background, 0.6, 'brighten');

open my $fh, '>>', "$output_file" or die "Cannot open $output_file: $!";

# Output background and foreground colors
print $fh "darkest=$darkest\n";
print $fh "base-transparent=$base_tr\n";
print $fh "base=$base\n";
print $fh "surface=$surface\n"; # background
print $fh "overlay=$overlay\n"; # background
print $fh "muted=$muted\n"; # foreground
print $fh "subtle=$subtle\n"; # foreground
print $fh "white=$foreground_color\n"; # foreground


# Generate color palette
for (my $i = 0; $i <= 7; $i++) {
    print $fh "color$i=$background\n"; # color0 - color7
}

# Generate gradient colors
my $gradient_ref = generate_gradient($background, 14);
for (my $i = 0; $i < scalar @$gradient_ref; $i++) {
    print $fh "gradient$i=$gradient_ref->[$i]\n";
}

sub hex_to_rgba {
    my ($color, $_opacity) = @_; 
    my ($r, $g, $b) = map { hex } $color =~ /(..)(..)(..)/;
    my $opacity = "$_opacity";
    return sprintf "rgba($r, $g, $b, $opacity)";
}

sub hex_to_rgb {
    my ($color) = @_; 
    my ($r, $g, $b) = map { hex } $color =~ /(..)(..)(..)/;
    return sprintf "rgba($r, $g, $b)";
}

# Function to adjust color brightness (darken or brighten)
sub adjust_color_brightness {
    my ($color, $percentage, $operation) = @_;
    my ($r, $g, $b) = map { hex } $color =~ /(..)(..)(..)/;
    if ($operation eq 'darken') {
        $r = int($r * $percentage);
        $g = int($g * $percentage);
        $b = int($b * $percentage);
    } elsif ($operation eq 'brighten') {
        $r = int($r + (255 - $r) * $percentage);
        $g = int($g + (255 - $g) * $percentage);
        $b = int($b + (255 - $b) * $percentage);
    }
    return sprintf("%02X%02X%02X", $r, $g, $b);
}

# Function to generate a gradient of 8 colors based on a given hex color
sub generate_gradient {
    my ($base_color, $steps) = @_;

    # Convert hex color to RGB components
    my ($r, $g, $b) = ($base_color =~ /(..)(..)(..)/);

    # Calculate step size for gradient
    my $step = 255 / $steps;

    # Generate gradient colors
    my @gradient_colors;
    for (my $i = 0; $i < 8; $i++) {
        my $new_r = sprintf("%02X", min(hex($r) + $step * $i, 255));
        my $new_g = sprintf("%02X", min(hex($g) + $step * $i, 255));
        my $new_b = sprintf("%02X", min(hex($b) + $step * $i, 255));

        my $color = "$new_r$new_g$new_b";
        push @gradient_colors, $color;
    }

    return \@gradient_colors;
}

# Usage: min($a, $b)
# Description: Function to get minimum of two values

# Usage: is_similar_color($color1, $color2)
# Description: Function to check if two colors are similar (within a certain threshold)
sub is_similar_color {
  my ($color1, $color2) = @_;
  my ($r1, $g1, $b1) = map { hex } $color1 =~ /(..)(..)(..)/;
  my ($r2, $g2, $b2) = map { hex } $color2 =~ /(..)(..)(..)/;
  
  my $threshold = 30; # Adjust the threshold as needed
  
  return abs($r1 - $r2) < $threshold && abs($g1 - $g2) < $threshold && abs($b1 - $b2) < $threshold;
}

# Usage: rgb_negative($hex_color)
# Description: Returns the negative hex color given: #00ffff -> #ff0000
sub rgb_negative {
    my ($hex_color) = @_;
    my $r = substr($hex_color, 0, 2);
    my $g = substr($hex_color, 2, 2);
    my $b = substr($hex_color, 4, 2);

    my $r16 = hex($r);
    my $g16 = hex($g);
    my $b16 = hex($b);

    $r = sprintf("%02X", 255 - $r16);
    $g = sprintf("%02X", 255 - $g16);
    $b = sprintf("%02X", 255 - $b16);

    return $r . $g . $b;
}

# Usage: rgb_negative($hex_color, $threshold)
# Description: Returns true if $hex_color's brightness is above the threshold
sub is_color_bright {
    my ($hex_color, $threshold) = @_;
    my ($r, $g, $b) = unpack("C*", pack("H*", $hex_color));

    # Calculate brightness
    my $brightness = ($r * 299 + $g * 587 + $b * 114) / 1000;

    # Check if brightness is above threshold
    return $brightness > $threshold;
}

sub is_color_not_too_bright {
    my ($hex_color, $threshold) = @_;
    my ($r, $g, $b) = unpack("C*", pack("H*", $hex_color));

    # Calculate brightness
    my $brightness = ($r * 299 + $g * 587 + $b * 114) / 1000;

    # Check if brightness is below threshold
    return $brightness < $threshold;
}

sub is_color_vibrant {
    my ($hex_color, $saturation_threshold, $brightness_threshold) = @_;

    # Remove '#' if present
    $hex_color =~ s/^#//;

    # Convert hex color to RGB components
    my ($r, $g, $b) = unpack("C*", pack("H*", $hex_color));

    # Calculate brightness
    my $brightness = ($r * 299 + $g * 587 + $b * 114) / 1000;

    # Calculate saturation
    my $min = min($r, $g, $b) / 255;
    my $max = max($r, $g, $b) / 255;
    my $delta = $max - $min;
    my $saturation = $max == 0 ? 0 : $delta / $max;

    # Check if color is vibrant (has high saturation and brightness)
    return $saturation > $saturation_threshold && $brightness > $brightness_threshold;
}

sub show_help {
    print "\nUsage: $0 <image_file>\n------------------------------------------------------------\n";
    print "| Options:  \n";
    print "| (Optional) Palette Type:   [-b|--balanced]   \n";
    print "|                            [-p|--pastel]    \n";
    print "|                            [-s|--stale] \n";
    print "|                            [-v|--vibrant]\n";
    print "|\n";
    print "| (Optional) Theme Type:     [-l|--light] \n";
    print "|                            [-d|--dark]\n";
    print "|\n";
    print "| (Mandatory) Color Backend: [-f|--fast] \n";
    print "|                            [-s|--slow]\n";
    print "|                            [-u|--ultraspeed]\n";
    print "|     \n";
    print "------------------------------------------------------------\n";
    exit 1;
}

# Function to calculate color difference using Euclidean distance
sub color_difference {
    my ($r1, $g1, $b1, $r2, $g2, $b2) = @_;
    return sqrt(($r2 - $r1) ** 2 + ($g2 - $g1) ** 2 + ($b2 - $b1) ** 2);
}

# Function to calculate brightness
sub calculate_brightness {
    my ($r, $g, $b) = @_;
    return ($r * 299 + $g * 587 + $b * 114) / 1000;
}

# Function to determine if colors are similar
sub are_colors_similar {
    my ($color1, $color2, $threshold) = @_;

    my ($r1, $g1, $b1) = hex_to_rgb($color1);
    my ($r2, $g2, $b2) = hex_to_rgb($color2);

    my $difference = color_difference($r1, $g1, $b1, $r2, $g2, $b2);

    return $difference <= $threshold;
}

# Function to compare brightness of two colors
sub compare_brightness {
    my ($color1, $color2) = @_;

    my ($r1, $g1, $b1) = hex_to_rgb($color1);
    my ($r2, $g2, $b2) = hex_to_rgb($color2);

    my $brightness1 = calculate_brightness($r1, $g1, $b1);
    my $brightness2 = calculate_brightness($r2, $g2, $b2);

    return $brightness1 <=> $brightness2;
}

sub check_brightness {
    my ($color) = @_;
    my $brightness = `magick $color -colorspace gray -format "%[fx:mean]" info:`;
    return $brightness < 0.5 ? 0 : 1;
}
